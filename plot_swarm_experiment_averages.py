#!/usr/bin/env python3
"""
Plot average knowledge-agent scores over time for self-learning and social-learning swarms.

The script expects two directory paths pointing to experiment cohorts (e.g.
`experiments/medium/self_learning_swarm/ka-25/career_fair_medium` and
`experiments/medium/social_learning_swarm/ka-25/career_fair_medium`). Each cohort
directory must contain subdirectories named `run_XXXX` with an `experiment.json`
file generated by `Environment.save_experiment_data`.

For every cohort the script:
  * loads all `*_score` series from every `experiment.json`;
  * averages the scores across knowledge agents within a run to obtain a single
    trajectory per experiment;
  * aggregates those trajectories across runs, computing the mean and standard
    deviation per timestep;
  * plots both aggregated trajectories on the same axes, shading Â±1 std dev in
    the same color as the corresponding average line and showing the variance in
    the legend; 
  * draws a horizontal baseline for a swarm with no learning;
  * saves the per-timestep statistics (means, standard deviations, variances) to
    a JSON file for reuse.

Usage example:
    python plot_swarm_experiment_averages.py \\
        experiments/medium/self_learning_swarm/ka-25/career_fair_medium \\
        experiments/medium/social_learning_swarm/ka-25/career_fair_medium \\
        --output experiments/medium/medium_ka25_swarm_comparison.png
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Sequence, Tuple

import matplotlib.pyplot as plt
import numpy as np


def _load_score_sequences(run_dir: Path) -> list[np.ndarray]:
    """Return score histories for all knowledge agents within a run directory."""
    experiment_path = run_dir / "experiment.json"
    if not experiment_path.exists():
        raise FileNotFoundError(f"Missing experiment.json in {run_dir}")

    with experiment_path.open("r", encoding="utf-8") as f:
        data = json.load(f)

    sequences: list[np.ndarray] = []
    for key, value in data.items():
        if key.endswith("_score"):
            seq = np.asarray(value, dtype=float)
            if seq.size:
                sequences.append(seq)
    return sequences


def _mean_over_agents(sequences: Sequence[np.ndarray]) -> np.ndarray:
    """Average score sequences across knowledge agents, padding with NaNs."""
    if not sequences:
        raise ValueError("No score sequences found for run.")

    max_len = max(seq.size for seq in sequences)
    stacked = np.full((len(sequences), max_len), np.nan, dtype=float)
    for idx, seq in enumerate(sequences):
        stacked[idx, : seq.size] = seq
    return np.nanmean(stacked, axis=0)


def aggregate_cohort(cohort_dir: Path) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    Compute per-timestep mean and standard deviation across all runs in a cohort.

    Returns:
        timesteps: 1-based timestep indices for which at least one run has data.
        mean: mean score at each timestep across runs.
        std: standard deviation of scores at each timestep across runs.
    """
    if not cohort_dir.exists():
        raise FileNotFoundError(f"Cohort directory does not exist: {cohort_dir}")

    run_dirs = sorted(
        d for d in cohort_dir.iterdir() if d.is_dir() and d.name.startswith("run_")
    )
    if not run_dirs:
        raise ValueError(f"No run_* subdirectories found in {cohort_dir}")

    run_averages: list[np.ndarray] = []
    for run_dir in run_dirs:
        sequences = _load_score_sequences(run_dir)
        if not sequences:
            continue
        run_averages.append(_mean_over_agents(sequences))

    if not run_averages:
        raise ValueError(f"No score data found in runs under {cohort_dir}")

    max_len = max(arr.size for arr in run_averages)
    stacked = np.full((len(run_averages), max_len), np.nan, dtype=float)
    for idx, arr in enumerate(run_averages):
        stacked[idx, : arr.size] = arr

    mean = np.nanmean(stacked, axis=0)
    std = np.nanstd(stacked, axis=0)

    valid_mask = ~np.isnan(mean)
    timesteps = np.arange(1, valid_mask.sum() + 1, dtype=int)
    mean = mean[valid_mask]
    std = std[valid_mask]

    return timesteps, mean, std


def save_stats_json(
    stats_output: Path,
    self_data: Tuple[np.ndarray, np.ndarray, np.ndarray],
    social_data: Tuple[np.ndarray, np.ndarray, np.ndarray],
) -> None:
    """Persist aggregated statistics for later reuse."""
    stats = {
        "self_learning": {
            "timesteps": self_data[0].tolist(),
            "mean": self_data[1].tolist(),
            "std": self_data[2].tolist(),
            "variance": (self_data[2] ** 2).tolist(),
        },
        "social_learning": {
            "timesteps": social_data[0].tolist(),
            "mean": social_data[1].tolist(),
            "std": social_data[2].tolist(),
            "variance": (social_data[2] ** 2).tolist(),
        },
        "baseline": {
            "score": 0.0,
            "description": "Swarm of 25 agents with no learning",
        },
    }

    stats_output.parent.mkdir(parents=True, exist_ok=True)
    with stats_output.open("w", encoding="utf-8") as f:
        json.dump(stats, f, ensure_ascii=False, indent=2)


def plot_cohorts(
    self_data: Tuple[np.ndarray, np.ndarray, np.ndarray],
    social_data: Tuple[np.ndarray, np.ndarray, np.ndarray],
    *,
    self_variance_summary: float,
    social_variance_summary: float,
    output_path: Path | None = None,
    show: bool = False,
) -> None:
    """Create the comparison plot and optionally save or display it."""
    plt.figure(figsize=(10, 6))
    ax = plt.gca()

    colors = {
        "self": "#1f77b4",  # Matplotlib default blue
        "social": "#d62728",  # Matplotlib default red
    }

    def _plot_series(
        timesteps: np.ndarray,
        mean: np.ndarray,
        std: np.ndarray,
        label: str,
        color: str,
    ) -> None:
        lower = mean - std
        upper = mean + std
        ax.plot(timesteps, mean, label=label, color=color, linewidth=2)
        ax.fill_between(timesteps, lower, upper, color=color, alpha=0.2)

    self_label = f"Self Learning Swarm (variance={self_variance_summary:.4f})"
    social_label = f"Social Learning Swarm (variance={social_variance_summary:.4f})"

    _plot_series(*self_data, label=self_label, color=colors["self"])
    _plot_series(*social_data, label=social_label, color=colors["social"])

    max_timestep = int(
        max(self_data[0][-1] if len(self_data[0]) else 0, social_data[0][-1] if len(social_data[0]) else 0)
    )
    if max_timestep > 0:
        baseline_timesteps = np.arange(1, max_timestep + 1, dtype=int)
        baseline_scores = np.zeros_like(baseline_timesteps, dtype=float)
        ax.plot(
            baseline_timesteps,
            baseline_scores,
            color="#ff7f0e",
            linewidth=2,
            label="No-Learning Baseline",
        )

    ax.set_xlabel("Evaluation Step")
    ax.set_ylabel("Score")
    ax.set_title("Average Knowledge-Agent Score Over Time (25 Agents per Swarm)")
    ax.grid(True, alpha=0.3, linestyle="--")
    ax.legend()

    if output_path is not None:
        output_path.parent.mkdir(parents=True, exist_ok=True)
        plt.savefig(output_path, dpi=300, bbox_inches="tight")

    if show:
        plt.show()
    else:
        plt.close(plt.gcf())


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Plot averaged experiment trajectories for self vs social learning swarms."
    )
    parser.add_argument(
        "self_dir",
        type=Path,
        help="Directory containing self-learning runs (run_XXXX subdirectories).",
    )
    parser.add_argument(
        "social_dir",
        type=Path,
        help="Directory containing social-learning runs (run_XXXX subdirectories).",
    )
    parser.add_argument(
        "--output",
        type=Path,
        default=None,
        help="Optional output filepath for the generated plot (PNG).",
    )
    parser.add_argument(
        "--stats-output",
        type=Path,
        default=None,
        help="Optional output filepath for aggregated statistics (JSON). "
        "Defaults to the plot path with a .json suffix, or ./swarm_stats.json if no plot path is provided.",
    )
    parser.add_argument(
        "--show",
        action="store_true",
        help="Display the plot window after generation.",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    self_data = aggregate_cohort(args.self_dir)
    social_data = aggregate_cohort(args.social_dir)

    self_variance = self_data[2] ** 2
    social_variance = social_data[2] ** 2

    self_variance_summary = float(np.nanmean(self_variance))
    social_variance_summary = float(np.nanmean(social_variance))

    plot_cohorts(
        self_data,
        social_data,
        self_variance_summary=self_variance_summary,
        social_variance_summary=social_variance_summary,
        output_path=args.output,
        show=args.show,
    )

    stats_output = args.stats_output
    if stats_output is None:
        if args.output is not None:
            stats_output = args.output.with_suffix(".json")
        else:
            stats_output = Path("swarm_stats.json")

    save_stats_json(stats_output, self_data, social_data)


if __name__ == "__main__":
    main()

